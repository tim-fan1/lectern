import {
    Arg,
    Field,
    ID,
    Mutation,
    ObjectType,
    Publisher,
    PubSub,
    Query,
    Resolver,
    Root,
    Subscription,
} from "type-graphql";
/*
Resolvers tell Type-Graphql how to "serialise" an object. Works in addition to @field'd objects

Queries represent a 'view' into the data
Mutations represent a state-changing operation

Don't forget to add to the resolvers list if more are added
*/

// Graphql objects for the bike shedding subscription
// this is not necessarily the way objects are stored in the backend,
// but the structure of the object that can be queried from the subscription
@ObjectType()
class BikeSheddingStatus {
    @Field((type) => ID)
    id!: number;

    @Field()
    isBikeShedding!: boolean;

    @Field()
    dateChanged!: Date;
}

// Example of how said object might be stored
const globalBike = {
    id: 0,
    groupName: "DFM, LLC",
    isBikeShedding: false,
};

// This is the "payload" used by the publisher
// this payload is passed to the subscription function, which can
// also make changes to the object
interface BikeSheddingPayload {
    id: number;
    isBikeShedding: boolean;
}

@Resolver()
export default class HelloResolver {
    // Basic hello World Query, which simply returns
    @Query(() => String)
    helloWorld() {
        return "Hello World!";
    }

    // This mutation changes the global bikeshedding status, and sends
    // a notification of this change to any connected clients
    // note that we use the "publisher" to send out events to our
    // @Subscription function
    @Mutation((returns) => Boolean)
    async bikeSheddingMutation(
        // the topic we are "sending" to
        @PubSub("BIKESHED") publish: Publisher<BikeSheddingPayload>,
        // the isBikeShedding status
        @Arg("isBikeShedding") isBikeShedding: boolean
    ) {
        globalBike.isBikeShedding = isBikeShedding;
        // "publish" to all clients - see bikeShedSubscription
        await publish({
            id: globalBike.id,
            isBikeShedding: globalBike.isBikeShedding,
        });
        return false;
    }

    // note that the connect logic is all handled internally by the library
    // the only connection related-option specified here is the name
    // of the graphql path that needs to be specified.
    // the syntax is the same as queries, except with subscription {}
    //
    // what this function does control is the exact data passed to clients
    // The function takes in a "payload" in its @Root() argument
    @Subscription((type) => BikeSheddingStatus, {
        topics: "BIKESHED",
    })
    bikeShedSubscription(
        @Root() notificationPayload: BikeSheddingPayload
    ): BikeSheddingStatus {
        // take in the BikeSheddingPayload generated by the publisher,
        // and add a timestamp for the client
        return {
            ...notificationPayload,
            dateChanged: new Date(),
        };
    }

    @Subscription((type) => BikeSheddingStatus, {
        topics: "BIKESHED",
        // some filter here - to filter out events generated
        // in this case, only send events to the client if
        // bikeShedding has been enabled
        filter: ({
            payload,
            args,
        }: {
            payload: BikeSheddingPayload;
            args: [];
        }) => {
            return payload.isBikeShedding === true;
        },
    })
    bikeShedEnabledSubscription(
        @Root() notificationPayload: BikeSheddingPayload
    ): BikeSheddingStatus {
        return {
            ...notificationPayload,
            dateChanged: new Date(),
        };
    }

    @Query((returns) => BikeSheddingStatus)
    bikeShedding() {
        return globalBike;
    }
}
